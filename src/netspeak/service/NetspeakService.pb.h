// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NetspeakService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_NetspeakService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_NetspeakService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_NetspeakService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_NetspeakService_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_NetspeakService_2eproto;
namespace netspeak {
namespace service {
class CorporaRequest;
class CorporaRequestDefaultTypeInternal;
extern CorporaRequestDefaultTypeInternal _CorporaRequest_default_instance_;
class CorporaResponse;
class CorporaResponseDefaultTypeInternal;
extern CorporaResponseDefaultTypeInternal _CorporaResponse_default_instance_;
class Corpus;
class CorpusDefaultTypeInternal;
extern CorpusDefaultTypeInternal _Corpus_default_instance_;
class Phrase;
class PhraseDefaultTypeInternal;
extern PhraseDefaultTypeInternal _Phrase_default_instance_;
class PhraseConstraints;
class PhraseConstraintsDefaultTypeInternal;
extern PhraseConstraintsDefaultTypeInternal _PhraseConstraints_default_instance_;
class Phrase_Word;
class Phrase_WordDefaultTypeInternal;
extern Phrase_WordDefaultTypeInternal _Phrase_Word_default_instance_;
class SearchRequest;
class SearchRequestDefaultTypeInternal;
extern SearchRequestDefaultTypeInternal _SearchRequest_default_instance_;
class SearchResponse;
class SearchResponseDefaultTypeInternal;
extern SearchResponseDefaultTypeInternal _SearchResponse_default_instance_;
class SearchResponse_Error;
class SearchResponse_ErrorDefaultTypeInternal;
extern SearchResponse_ErrorDefaultTypeInternal _SearchResponse_Error_default_instance_;
class SearchResponse_Result;
class SearchResponse_ResultDefaultTypeInternal;
extern SearchResponse_ResultDefaultTypeInternal _SearchResponse_Result_default_instance_;
}  // namespace service
}  // namespace netspeak
PROTOBUF_NAMESPACE_OPEN
template<> ::netspeak::service::CorporaRequest* Arena::CreateMaybeMessage<::netspeak::service::CorporaRequest>(Arena*);
template<> ::netspeak::service::CorporaResponse* Arena::CreateMaybeMessage<::netspeak::service::CorporaResponse>(Arena*);
template<> ::netspeak::service::Corpus* Arena::CreateMaybeMessage<::netspeak::service::Corpus>(Arena*);
template<> ::netspeak::service::Phrase* Arena::CreateMaybeMessage<::netspeak::service::Phrase>(Arena*);
template<> ::netspeak::service::PhraseConstraints* Arena::CreateMaybeMessage<::netspeak::service::PhraseConstraints>(Arena*);
template<> ::netspeak::service::Phrase_Word* Arena::CreateMaybeMessage<::netspeak::service::Phrase_Word>(Arena*);
template<> ::netspeak::service::SearchRequest* Arena::CreateMaybeMessage<::netspeak::service::SearchRequest>(Arena*);
template<> ::netspeak::service::SearchResponse* Arena::CreateMaybeMessage<::netspeak::service::SearchResponse>(Arena*);
template<> ::netspeak::service::SearchResponse_Error* Arena::CreateMaybeMessage<::netspeak::service::SearchResponse_Error>(Arena*);
template<> ::netspeak::service::SearchResponse_Result* Arena::CreateMaybeMessage<::netspeak::service::SearchResponse_Result>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace netspeak {
namespace service {

enum Phrase_Word_Tag : int {
  Phrase_Word_Tag_WORD = 0,
  Phrase_Word_Tag_WORD_FOR_QMARK = 1,
  Phrase_Word_Tag_WORD_FOR_STAR = 2,
  Phrase_Word_Tag_WORD_IN_DICTSET = 3,
  Phrase_Word_Tag_WORD_IN_ORDERSET = 4,
  Phrase_Word_Tag_WORD_IN_OPTIONSET = 5,
  Phrase_Word_Tag_WORD_FOR_PLUS = 6,
  Phrase_Word_Tag_WORD_FOR_REGEX = 7,
  Phrase_Word_Tag_Phrase_Word_Tag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Phrase_Word_Tag_Phrase_Word_Tag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Phrase_Word_Tag_IsValid(int value);
constexpr Phrase_Word_Tag Phrase_Word_Tag_Tag_MIN = Phrase_Word_Tag_WORD;
constexpr Phrase_Word_Tag Phrase_Word_Tag_Tag_MAX = Phrase_Word_Tag_WORD_FOR_REGEX;
constexpr int Phrase_Word_Tag_Tag_ARRAYSIZE = Phrase_Word_Tag_Tag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Phrase_Word_Tag_descriptor();
template<typename T>
inline const std::string& Phrase_Word_Tag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Phrase_Word_Tag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Phrase_Word_Tag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Phrase_Word_Tag_descriptor(), enum_t_value);
}
inline bool Phrase_Word_Tag_Parse(
    const std::string& name, Phrase_Word_Tag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Phrase_Word_Tag>(
    Phrase_Word_Tag_descriptor(), name, value);
}
enum SearchResponse_Error_Kind : int {
  SearchResponse_Error_Kind_UNKNOWN = 0,
  SearchResponse_Error_Kind_INTERNAL_ERROR = 1,
  SearchResponse_Error_Kind_INVALID_PARAMETER = 100,
  SearchResponse_Error_Kind_INVALID_QUERY = 110,
  SearchResponse_Error_Kind_INVALID_CORPUS = 111,
  SearchResponse_Error_Kind_SearchResponse_Error_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SearchResponse_Error_Kind_SearchResponse_Error_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SearchResponse_Error_Kind_IsValid(int value);
constexpr SearchResponse_Error_Kind SearchResponse_Error_Kind_Kind_MIN = SearchResponse_Error_Kind_UNKNOWN;
constexpr SearchResponse_Error_Kind SearchResponse_Error_Kind_Kind_MAX = SearchResponse_Error_Kind_INVALID_CORPUS;
constexpr int SearchResponse_Error_Kind_Kind_ARRAYSIZE = SearchResponse_Error_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SearchResponse_Error_Kind_descriptor();
template<typename T>
inline const std::string& SearchResponse_Error_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SearchResponse_Error_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SearchResponse_Error_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SearchResponse_Error_Kind_descriptor(), enum_t_value);
}
inline bool SearchResponse_Error_Kind_Parse(
    const std::string& name, SearchResponse_Error_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SearchResponse_Error_Kind>(
    SearchResponse_Error_Kind_descriptor(), name, value);
}
// ===================================================================

class SearchRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netspeak.service.SearchRequest) */ {
 public:
  SearchRequest();
  virtual ~SearchRequest();

  SearchRequest(const SearchRequest& from);
  SearchRequest(SearchRequest&& from) noexcept
    : SearchRequest() {
    *this = ::std::move(from);
  }

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchRequest& operator=(SearchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SearchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchRequest* internal_default_instance() {
    return reinterpret_cast<const SearchRequest*>(
               &_SearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SearchRequest& a, SearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchRequest* New() const final {
    return CreateMaybeMessage<SearchRequest>(nullptr);
  }

  SearchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SearchRequest& from);
  void MergeFrom(const SearchRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netspeak.service.SearchRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NetspeakService_2eproto);
    return ::descriptor_table_NetspeakService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
    kCorpusFieldNumber = 2,
    kPhraseConstraintsFieldNumber = 4,
    kMaxPhrasesFieldNumber = 3,
  };
  // string query = 1;
  void clear_query();
  const std::string& query() const;
  void set_query(const std::string& value);
  void set_query(std::string&& value);
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  std::string* mutable_query();
  std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // string corpus = 2;
  void clear_corpus();
  const std::string& corpus() const;
  void set_corpus(const std::string& value);
  void set_corpus(std::string&& value);
  void set_corpus(const char* value);
  void set_corpus(const char* value, size_t size);
  std::string* mutable_corpus();
  std::string* release_corpus();
  void set_allocated_corpus(std::string* corpus);
  private:
  const std::string& _internal_corpus() const;
  void _internal_set_corpus(const std::string& value);
  std::string* _internal_mutable_corpus();
  public:

  // .netspeak.service.PhraseConstraints phrase_constraints = 4;
  bool has_phrase_constraints() const;
  private:
  bool _internal_has_phrase_constraints() const;
  public:
  void clear_phrase_constraints();
  const ::netspeak::service::PhraseConstraints& phrase_constraints() const;
  ::netspeak::service::PhraseConstraints* release_phrase_constraints();
  ::netspeak::service::PhraseConstraints* mutable_phrase_constraints();
  void set_allocated_phrase_constraints(::netspeak::service::PhraseConstraints* phrase_constraints);
  private:
  const ::netspeak::service::PhraseConstraints& _internal_phrase_constraints() const;
  ::netspeak::service::PhraseConstraints* _internal_mutable_phrase_constraints();
  public:

  // uint32 max_phrases = 3;
  void clear_max_phrases();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_phrases() const;
  void set_max_phrases(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_phrases() const;
  void _internal_set_max_phrases(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:netspeak.service.SearchRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr corpus_;
  ::netspeak::service::PhraseConstraints* phrase_constraints_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_phrases_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NetspeakService_2eproto;
};
// -------------------------------------------------------------------

class PhraseConstraints :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netspeak.service.PhraseConstraints) */ {
 public:
  PhraseConstraints();
  virtual ~PhraseConstraints();

  PhraseConstraints(const PhraseConstraints& from);
  PhraseConstraints(PhraseConstraints&& from) noexcept
    : PhraseConstraints() {
    *this = ::std::move(from);
  }

  inline PhraseConstraints& operator=(const PhraseConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhraseConstraints& operator=(PhraseConstraints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhraseConstraints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhraseConstraints* internal_default_instance() {
    return reinterpret_cast<const PhraseConstraints*>(
               &_PhraseConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PhraseConstraints& a, PhraseConstraints& b) {
    a.Swap(&b);
  }
  inline void Swap(PhraseConstraints* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhraseConstraints* New() const final {
    return CreateMaybeMessage<PhraseConstraints>(nullptr);
  }

  PhraseConstraints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhraseConstraints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhraseConstraints& from);
  void MergeFrom(const PhraseConstraints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhraseConstraints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netspeak.service.PhraseConstraints";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NetspeakService_2eproto);
    return ::descriptor_table_NetspeakService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrequencyMaxFieldNumber = 1,
    kWordsMinFieldNumber = 2,
    kWordsMaxFieldNumber = 3,
  };
  // uint64 frequency_max = 1;
  void clear_frequency_max();
  ::PROTOBUF_NAMESPACE_ID::uint64 frequency_max() const;
  void set_frequency_max(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_frequency_max() const;
  void _internal_set_frequency_max(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 words_min = 2;
  void clear_words_min();
  ::PROTOBUF_NAMESPACE_ID::uint32 words_min() const;
  void set_words_min(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_words_min() const;
  void _internal_set_words_min(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 words_max = 3;
  void clear_words_max();
  ::PROTOBUF_NAMESPACE_ID::uint32 words_max() const;
  void set_words_max(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_words_max() const;
  void _internal_set_words_max(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:netspeak.service.PhraseConstraints)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 frequency_max_;
  ::PROTOBUF_NAMESPACE_ID::uint32 words_min_;
  ::PROTOBUF_NAMESPACE_ID::uint32 words_max_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NetspeakService_2eproto;
};
// -------------------------------------------------------------------

class Phrase_Word :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netspeak.service.Phrase.Word) */ {
 public:
  Phrase_Word();
  virtual ~Phrase_Word();

  Phrase_Word(const Phrase_Word& from);
  Phrase_Word(Phrase_Word&& from) noexcept
    : Phrase_Word() {
    *this = ::std::move(from);
  }

  inline Phrase_Word& operator=(const Phrase_Word& from) {
    CopyFrom(from);
    return *this;
  }
  inline Phrase_Word& operator=(Phrase_Word&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Phrase_Word& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Phrase_Word* internal_default_instance() {
    return reinterpret_cast<const Phrase_Word*>(
               &_Phrase_Word_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Phrase_Word& a, Phrase_Word& b) {
    a.Swap(&b);
  }
  inline void Swap(Phrase_Word* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Phrase_Word* New() const final {
    return CreateMaybeMessage<Phrase_Word>(nullptr);
  }

  Phrase_Word* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Phrase_Word>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Phrase_Word& from);
  void MergeFrom(const Phrase_Word& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Phrase_Word* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netspeak.service.Phrase.Word";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NetspeakService_2eproto);
    return ::descriptor_table_NetspeakService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Phrase_Word_Tag Tag;
  static constexpr Tag WORD =
    Phrase_Word_Tag_WORD;
  static constexpr Tag WORD_FOR_QMARK =
    Phrase_Word_Tag_WORD_FOR_QMARK;
  static constexpr Tag WORD_FOR_STAR =
    Phrase_Word_Tag_WORD_FOR_STAR;
  static constexpr Tag WORD_IN_DICTSET =
    Phrase_Word_Tag_WORD_IN_DICTSET;
  static constexpr Tag WORD_IN_ORDERSET =
    Phrase_Word_Tag_WORD_IN_ORDERSET;
  static constexpr Tag WORD_IN_OPTIONSET =
    Phrase_Word_Tag_WORD_IN_OPTIONSET;
  static constexpr Tag WORD_FOR_PLUS =
    Phrase_Word_Tag_WORD_FOR_PLUS;
  static constexpr Tag WORD_FOR_REGEX =
    Phrase_Word_Tag_WORD_FOR_REGEX;
  static inline bool Tag_IsValid(int value) {
    return Phrase_Word_Tag_IsValid(value);
  }
  static constexpr Tag Tag_MIN =
    Phrase_Word_Tag_Tag_MIN;
  static constexpr Tag Tag_MAX =
    Phrase_Word_Tag_Tag_MAX;
  static constexpr int Tag_ARRAYSIZE =
    Phrase_Word_Tag_Tag_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Tag_descriptor() {
    return Phrase_Word_Tag_descriptor();
  }
  template<typename T>
  static inline const std::string& Tag_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Tag>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Tag_Name.");
    return Phrase_Word_Tag_Name(enum_t_value);
  }
  static inline bool Tag_Parse(const std::string& name,
      Tag* value) {
    return Phrase_Word_Tag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kTagFieldNumber = 1,
  };
  // string text = 2;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .netspeak.service.Phrase.Word.Tag tag = 1;
  void clear_tag();
  ::netspeak::service::Phrase_Word_Tag tag() const;
  void set_tag(::netspeak::service::Phrase_Word_Tag value);
  private:
  ::netspeak::service::Phrase_Word_Tag _internal_tag() const;
  void _internal_set_tag(::netspeak::service::Phrase_Word_Tag value);
  public:

  // @@protoc_insertion_point(class_scope:netspeak.service.Phrase.Word)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  int tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NetspeakService_2eproto;
};
// -------------------------------------------------------------------

class Phrase :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netspeak.service.Phrase) */ {
 public:
  Phrase();
  virtual ~Phrase();

  Phrase(const Phrase& from);
  Phrase(Phrase&& from) noexcept
    : Phrase() {
    *this = ::std::move(from);
  }

  inline Phrase& operator=(const Phrase& from) {
    CopyFrom(from);
    return *this;
  }
  inline Phrase& operator=(Phrase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Phrase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Phrase* internal_default_instance() {
    return reinterpret_cast<const Phrase*>(
               &_Phrase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Phrase& a, Phrase& b) {
    a.Swap(&b);
  }
  inline void Swap(Phrase* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Phrase* New() const final {
    return CreateMaybeMessage<Phrase>(nullptr);
  }

  Phrase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Phrase>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Phrase& from);
  void MergeFrom(const Phrase& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Phrase* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netspeak.service.Phrase";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NetspeakService_2eproto);
    return ::descriptor_table_NetspeakService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Phrase_Word Word;

  // accessors -------------------------------------------------------

  enum : int {
    kWordsFieldNumber = 3,
    kIdFieldNumber = 1,
    kFrequencyFieldNumber = 2,
  };
  // repeated .netspeak.service.Phrase.Word words = 3;
  int words_size() const;
  private:
  int _internal_words_size() const;
  public:
  void clear_words();
  ::netspeak::service::Phrase_Word* mutable_words(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Phrase_Word >*
      mutable_words();
  private:
  const ::netspeak::service::Phrase_Word& _internal_words(int index) const;
  ::netspeak::service::Phrase_Word* _internal_add_words();
  public:
  const ::netspeak::service::Phrase_Word& words(int index) const;
  ::netspeak::service::Phrase_Word* add_words();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Phrase_Word >&
      words() const;

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 frequency = 2;
  void clear_frequency();
  ::PROTOBUF_NAMESPACE_ID::uint64 frequency() const;
  void set_frequency(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_frequency() const;
  void _internal_set_frequency(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:netspeak.service.Phrase)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Phrase_Word > words_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 frequency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NetspeakService_2eproto;
};
// -------------------------------------------------------------------

class SearchResponse_Result :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netspeak.service.SearchResponse.Result) */ {
 public:
  SearchResponse_Result();
  virtual ~SearchResponse_Result();

  SearchResponse_Result(const SearchResponse_Result& from);
  SearchResponse_Result(SearchResponse_Result&& from) noexcept
    : SearchResponse_Result() {
    *this = ::std::move(from);
  }

  inline SearchResponse_Result& operator=(const SearchResponse_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse_Result& operator=(SearchResponse_Result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SearchResponse_Result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchResponse_Result* internal_default_instance() {
    return reinterpret_cast<const SearchResponse_Result*>(
               &_SearchResponse_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SearchResponse_Result& a, SearchResponse_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResponse_Result* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResponse_Result* New() const final {
    return CreateMaybeMessage<SearchResponse_Result>(nullptr);
  }

  SearchResponse_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResponse_Result>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SearchResponse_Result& from);
  void MergeFrom(const SearchResponse_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResponse_Result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netspeak.service.SearchResponse.Result";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NetspeakService_2eproto);
    return ::descriptor_table_NetspeakService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhrasesFieldNumber = 1,
    kUnknownWordsFieldNumber = 2,
  };
  // repeated .netspeak.service.Phrase phrases = 1;
  int phrases_size() const;
  private:
  int _internal_phrases_size() const;
  public:
  void clear_phrases();
  ::netspeak::service::Phrase* mutable_phrases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Phrase >*
      mutable_phrases();
  private:
  const ::netspeak::service::Phrase& _internal_phrases(int index) const;
  ::netspeak::service::Phrase* _internal_add_phrases();
  public:
  const ::netspeak::service::Phrase& phrases(int index) const;
  ::netspeak::service::Phrase* add_phrases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Phrase >&
      phrases() const;

  // repeated string unknown_words = 2;
  int unknown_words_size() const;
  private:
  int _internal_unknown_words_size() const;
  public:
  void clear_unknown_words();
  const std::string& unknown_words(int index) const;
  std::string* mutable_unknown_words(int index);
  void set_unknown_words(int index, const std::string& value);
  void set_unknown_words(int index, std::string&& value);
  void set_unknown_words(int index, const char* value);
  void set_unknown_words(int index, const char* value, size_t size);
  std::string* add_unknown_words();
  void add_unknown_words(const std::string& value);
  void add_unknown_words(std::string&& value);
  void add_unknown_words(const char* value);
  void add_unknown_words(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& unknown_words() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_unknown_words();
  private:
  const std::string& _internal_unknown_words(int index) const;
  std::string* _internal_add_unknown_words();
  public:

  // @@protoc_insertion_point(class_scope:netspeak.service.SearchResponse.Result)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Phrase > phrases_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> unknown_words_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NetspeakService_2eproto;
};
// -------------------------------------------------------------------

class SearchResponse_Error :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netspeak.service.SearchResponse.Error) */ {
 public:
  SearchResponse_Error();
  virtual ~SearchResponse_Error();

  SearchResponse_Error(const SearchResponse_Error& from);
  SearchResponse_Error(SearchResponse_Error&& from) noexcept
    : SearchResponse_Error() {
    *this = ::std::move(from);
  }

  inline SearchResponse_Error& operator=(const SearchResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse_Error& operator=(SearchResponse_Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SearchResponse_Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchResponse_Error* internal_default_instance() {
    return reinterpret_cast<const SearchResponse_Error*>(
               &_SearchResponse_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SearchResponse_Error& a, SearchResponse_Error& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResponse_Error* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResponse_Error* New() const final {
    return CreateMaybeMessage<SearchResponse_Error>(nullptr);
  }

  SearchResponse_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResponse_Error>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SearchResponse_Error& from);
  void MergeFrom(const SearchResponse_Error& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResponse_Error* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netspeak.service.SearchResponse.Error";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NetspeakService_2eproto);
    return ::descriptor_table_NetspeakService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SearchResponse_Error_Kind Kind;
  static constexpr Kind UNKNOWN =
    SearchResponse_Error_Kind_UNKNOWN;
  static constexpr Kind INTERNAL_ERROR =
    SearchResponse_Error_Kind_INTERNAL_ERROR;
  static constexpr Kind INVALID_PARAMETER =
    SearchResponse_Error_Kind_INVALID_PARAMETER;
  static constexpr Kind INVALID_QUERY =
    SearchResponse_Error_Kind_INVALID_QUERY;
  static constexpr Kind INVALID_CORPUS =
    SearchResponse_Error_Kind_INVALID_CORPUS;
  static inline bool Kind_IsValid(int value) {
    return SearchResponse_Error_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    SearchResponse_Error_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    SearchResponse_Error_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    SearchResponse_Error_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return SearchResponse_Error_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return SearchResponse_Error_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(const std::string& name,
      Kind* value) {
    return SearchResponse_Error_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kKindFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .netspeak.service.SearchResponse.Error.Kind kind = 1;
  void clear_kind();
  ::netspeak::service::SearchResponse_Error_Kind kind() const;
  void set_kind(::netspeak::service::SearchResponse_Error_Kind value);
  private:
  ::netspeak::service::SearchResponse_Error_Kind _internal_kind() const;
  void _internal_set_kind(::netspeak::service::SearchResponse_Error_Kind value);
  public:

  // @@protoc_insertion_point(class_scope:netspeak.service.SearchResponse.Error)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NetspeakService_2eproto;
};
// -------------------------------------------------------------------

class SearchResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netspeak.service.SearchResponse) */ {
 public:
  SearchResponse();
  virtual ~SearchResponse();

  SearchResponse(const SearchResponse& from);
  SearchResponse(SearchResponse&& from) noexcept
    : SearchResponse() {
    *this = ::std::move(from);
  }

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse& operator=(SearchResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SearchResponse& default_instance();

  enum ResponseCase {
    kResult = 1,
    kError = 2,
    RESPONSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchResponse* internal_default_instance() {
    return reinterpret_cast<const SearchResponse*>(
               &_SearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SearchResponse& a, SearchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResponse* New() const final {
    return CreateMaybeMessage<SearchResponse>(nullptr);
  }

  SearchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SearchResponse& from);
  void MergeFrom(const SearchResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netspeak.service.SearchResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NetspeakService_2eproto);
    return ::descriptor_table_NetspeakService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SearchResponse_Result Result;
  typedef SearchResponse_Error Error;

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .netspeak.service.SearchResponse.Result result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::netspeak::service::SearchResponse_Result& result() const;
  ::netspeak::service::SearchResponse_Result* release_result();
  ::netspeak::service::SearchResponse_Result* mutable_result();
  void set_allocated_result(::netspeak::service::SearchResponse_Result* result);
  private:
  const ::netspeak::service::SearchResponse_Result& _internal_result() const;
  ::netspeak::service::SearchResponse_Result* _internal_mutable_result();
  public:

  // .netspeak.service.SearchResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::netspeak::service::SearchResponse_Error& error() const;
  ::netspeak::service::SearchResponse_Error* release_error();
  ::netspeak::service::SearchResponse_Error* mutable_error();
  void set_allocated_error(::netspeak::service::SearchResponse_Error* error);
  private:
  const ::netspeak::service::SearchResponse_Error& _internal_error() const;
  ::netspeak::service::SearchResponse_Error* _internal_mutable_error();
  public:

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:netspeak.service.SearchResponse)
 private:
  class _Internal;
  void set_has_result();
  void set_has_error();

  inline bool has_response() const;
  inline void clear_has_response();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ResponseUnion {
    ResponseUnion() {}
    ::netspeak::service::SearchResponse_Result* result_;
    ::netspeak::service::SearchResponse_Error* error_;
  } response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_NetspeakService_2eproto;
};
// -------------------------------------------------------------------

class CorporaRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netspeak.service.CorporaRequest) */ {
 public:
  CorporaRequest();
  virtual ~CorporaRequest();

  CorporaRequest(const CorporaRequest& from);
  CorporaRequest(CorporaRequest&& from) noexcept
    : CorporaRequest() {
    *this = ::std::move(from);
  }

  inline CorporaRequest& operator=(const CorporaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CorporaRequest& operator=(CorporaRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CorporaRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CorporaRequest* internal_default_instance() {
    return reinterpret_cast<const CorporaRequest*>(
               &_CorporaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CorporaRequest& a, CorporaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CorporaRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CorporaRequest* New() const final {
    return CreateMaybeMessage<CorporaRequest>(nullptr);
  }

  CorporaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CorporaRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CorporaRequest& from);
  void MergeFrom(const CorporaRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CorporaRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netspeak.service.CorporaRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NetspeakService_2eproto);
    return ::descriptor_table_NetspeakService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:netspeak.service.CorporaRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NetspeakService_2eproto;
};
// -------------------------------------------------------------------

class Corpus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netspeak.service.Corpus) */ {
 public:
  Corpus();
  virtual ~Corpus();

  Corpus(const Corpus& from);
  Corpus(Corpus&& from) noexcept
    : Corpus() {
    *this = ::std::move(from);
  }

  inline Corpus& operator=(const Corpus& from) {
    CopyFrom(from);
    return *this;
  }
  inline Corpus& operator=(Corpus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Corpus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Corpus* internal_default_instance() {
    return reinterpret_cast<const Corpus*>(
               &_Corpus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Corpus& a, Corpus& b) {
    a.Swap(&b);
  }
  inline void Swap(Corpus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Corpus* New() const final {
    return CreateMaybeMessage<Corpus>(nullptr);
  }

  Corpus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Corpus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Corpus& from);
  void MergeFrom(const Corpus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Corpus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netspeak.service.Corpus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NetspeakService_2eproto);
    return ::descriptor_table_NetspeakService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kNameFieldNumber = 2,
    kLanguageFieldNumber = 3,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string language = 3;
  void clear_language();
  const std::string& language() const;
  void set_language(const std::string& value);
  void set_language(std::string&& value);
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  std::string* mutable_language();
  std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // @@protoc_insertion_point(class_scope:netspeak.service.Corpus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NetspeakService_2eproto;
};
// -------------------------------------------------------------------

class CorporaResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:netspeak.service.CorporaResponse) */ {
 public:
  CorporaResponse();
  virtual ~CorporaResponse();

  CorporaResponse(const CorporaResponse& from);
  CorporaResponse(CorporaResponse&& from) noexcept
    : CorporaResponse() {
    *this = ::std::move(from);
  }

  inline CorporaResponse& operator=(const CorporaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CorporaResponse& operator=(CorporaResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CorporaResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CorporaResponse* internal_default_instance() {
    return reinterpret_cast<const CorporaResponse*>(
               &_CorporaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CorporaResponse& a, CorporaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CorporaResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CorporaResponse* New() const final {
    return CreateMaybeMessage<CorporaResponse>(nullptr);
  }

  CorporaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CorporaResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CorporaResponse& from);
  void MergeFrom(const CorporaResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CorporaResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "netspeak.service.CorporaResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NetspeakService_2eproto);
    return ::descriptor_table_NetspeakService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCorporaFieldNumber = 1,
  };
  // repeated .netspeak.service.Corpus corpora = 1;
  int corpora_size() const;
  private:
  int _internal_corpora_size() const;
  public:
  void clear_corpora();
  ::netspeak::service::Corpus* mutable_corpora(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Corpus >*
      mutable_corpora();
  private:
  const ::netspeak::service::Corpus& _internal_corpora(int index) const;
  ::netspeak::service::Corpus* _internal_add_corpora();
  public:
  const ::netspeak::service::Corpus& corpora(int index) const;
  ::netspeak::service::Corpus* add_corpora();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Corpus >&
      corpora() const;

  // @@protoc_insertion_point(class_scope:netspeak.service.CorporaResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Corpus > corpora_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NetspeakService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SearchRequest

// string query = 1;
inline void SearchRequest::clear_query() {
  query_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SearchRequest::query() const {
  // @@protoc_insertion_point(field_get:netspeak.service.SearchRequest.query)
  return _internal_query();
}
inline void SearchRequest::set_query(const std::string& value) {
  _internal_set_query(value);
  // @@protoc_insertion_point(field_set:netspeak.service.SearchRequest.query)
}
inline std::string* SearchRequest::mutable_query() {
  // @@protoc_insertion_point(field_mutable:netspeak.service.SearchRequest.query)
  return _internal_mutable_query();
}
inline const std::string& SearchRequest::_internal_query() const {
  return query_.GetNoArena();
}
inline void SearchRequest::_internal_set_query(const std::string& value) {
  
  query_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SearchRequest::set_query(std::string&& value) {
  
  query_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netspeak.service.SearchRequest.query)
}
inline void SearchRequest::set_query(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  query_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netspeak.service.SearchRequest.query)
}
inline void SearchRequest::set_query(const char* value, size_t size) {
  
  query_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netspeak.service.SearchRequest.query)
}
inline std::string* SearchRequest::_internal_mutable_query() {
  
  return query_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SearchRequest::release_query() {
  // @@protoc_insertion_point(field_release:netspeak.service.SearchRequest.query)
  
  return query_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SearchRequest::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    
  } else {
    
  }
  query_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:netspeak.service.SearchRequest.query)
}

// string corpus = 2;
inline void SearchRequest::clear_corpus() {
  corpus_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SearchRequest::corpus() const {
  // @@protoc_insertion_point(field_get:netspeak.service.SearchRequest.corpus)
  return _internal_corpus();
}
inline void SearchRequest::set_corpus(const std::string& value) {
  _internal_set_corpus(value);
  // @@protoc_insertion_point(field_set:netspeak.service.SearchRequest.corpus)
}
inline std::string* SearchRequest::mutable_corpus() {
  // @@protoc_insertion_point(field_mutable:netspeak.service.SearchRequest.corpus)
  return _internal_mutable_corpus();
}
inline const std::string& SearchRequest::_internal_corpus() const {
  return corpus_.GetNoArena();
}
inline void SearchRequest::_internal_set_corpus(const std::string& value) {
  
  corpus_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SearchRequest::set_corpus(std::string&& value) {
  
  corpus_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netspeak.service.SearchRequest.corpus)
}
inline void SearchRequest::set_corpus(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  corpus_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netspeak.service.SearchRequest.corpus)
}
inline void SearchRequest::set_corpus(const char* value, size_t size) {
  
  corpus_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netspeak.service.SearchRequest.corpus)
}
inline std::string* SearchRequest::_internal_mutable_corpus() {
  
  return corpus_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SearchRequest::release_corpus() {
  // @@protoc_insertion_point(field_release:netspeak.service.SearchRequest.corpus)
  
  return corpus_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SearchRequest::set_allocated_corpus(std::string* corpus) {
  if (corpus != nullptr) {
    
  } else {
    
  }
  corpus_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), corpus);
  // @@protoc_insertion_point(field_set_allocated:netspeak.service.SearchRequest.corpus)
}

// uint32 max_phrases = 3;
inline void SearchRequest::clear_max_phrases() {
  max_phrases_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SearchRequest::_internal_max_phrases() const {
  return max_phrases_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SearchRequest::max_phrases() const {
  // @@protoc_insertion_point(field_get:netspeak.service.SearchRequest.max_phrases)
  return _internal_max_phrases();
}
inline void SearchRequest::_internal_set_max_phrases(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  max_phrases_ = value;
}
inline void SearchRequest::set_max_phrases(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_phrases(value);
  // @@protoc_insertion_point(field_set:netspeak.service.SearchRequest.max_phrases)
}

// .netspeak.service.PhraseConstraints phrase_constraints = 4;
inline bool SearchRequest::_internal_has_phrase_constraints() const {
  return this != internal_default_instance() && phrase_constraints_ != nullptr;
}
inline bool SearchRequest::has_phrase_constraints() const {
  return _internal_has_phrase_constraints();
}
inline void SearchRequest::clear_phrase_constraints() {
  if (GetArenaNoVirtual() == nullptr && phrase_constraints_ != nullptr) {
    delete phrase_constraints_;
  }
  phrase_constraints_ = nullptr;
}
inline const ::netspeak::service::PhraseConstraints& SearchRequest::_internal_phrase_constraints() const {
  const ::netspeak::service::PhraseConstraints* p = phrase_constraints_;
  return p != nullptr ? *p : *reinterpret_cast<const ::netspeak::service::PhraseConstraints*>(
      &::netspeak::service::_PhraseConstraints_default_instance_);
}
inline const ::netspeak::service::PhraseConstraints& SearchRequest::phrase_constraints() const {
  // @@protoc_insertion_point(field_get:netspeak.service.SearchRequest.phrase_constraints)
  return _internal_phrase_constraints();
}
inline ::netspeak::service::PhraseConstraints* SearchRequest::release_phrase_constraints() {
  // @@protoc_insertion_point(field_release:netspeak.service.SearchRequest.phrase_constraints)
  
  ::netspeak::service::PhraseConstraints* temp = phrase_constraints_;
  phrase_constraints_ = nullptr;
  return temp;
}
inline ::netspeak::service::PhraseConstraints* SearchRequest::_internal_mutable_phrase_constraints() {
  
  if (phrase_constraints_ == nullptr) {
    auto* p = CreateMaybeMessage<::netspeak::service::PhraseConstraints>(GetArenaNoVirtual());
    phrase_constraints_ = p;
  }
  return phrase_constraints_;
}
inline ::netspeak::service::PhraseConstraints* SearchRequest::mutable_phrase_constraints() {
  // @@protoc_insertion_point(field_mutable:netspeak.service.SearchRequest.phrase_constraints)
  return _internal_mutable_phrase_constraints();
}
inline void SearchRequest::set_allocated_phrase_constraints(::netspeak::service::PhraseConstraints* phrase_constraints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phrase_constraints_;
  }
  if (phrase_constraints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phrase_constraints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phrase_constraints, submessage_arena);
    }
    
  } else {
    
  }
  phrase_constraints_ = phrase_constraints;
  // @@protoc_insertion_point(field_set_allocated:netspeak.service.SearchRequest.phrase_constraints)
}

// -------------------------------------------------------------------

// PhraseConstraints

// uint64 frequency_max = 1;
inline void PhraseConstraints::clear_frequency_max() {
  frequency_max_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PhraseConstraints::_internal_frequency_max() const {
  return frequency_max_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PhraseConstraints::frequency_max() const {
  // @@protoc_insertion_point(field_get:netspeak.service.PhraseConstraints.frequency_max)
  return _internal_frequency_max();
}
inline void PhraseConstraints::_internal_set_frequency_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  frequency_max_ = value;
}
inline void PhraseConstraints::set_frequency_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_frequency_max(value);
  // @@protoc_insertion_point(field_set:netspeak.service.PhraseConstraints.frequency_max)
}

// uint32 words_min = 2;
inline void PhraseConstraints::clear_words_min() {
  words_min_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PhraseConstraints::_internal_words_min() const {
  return words_min_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PhraseConstraints::words_min() const {
  // @@protoc_insertion_point(field_get:netspeak.service.PhraseConstraints.words_min)
  return _internal_words_min();
}
inline void PhraseConstraints::_internal_set_words_min(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  words_min_ = value;
}
inline void PhraseConstraints::set_words_min(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_words_min(value);
  // @@protoc_insertion_point(field_set:netspeak.service.PhraseConstraints.words_min)
}

// uint32 words_max = 3;
inline void PhraseConstraints::clear_words_max() {
  words_max_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PhraseConstraints::_internal_words_max() const {
  return words_max_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PhraseConstraints::words_max() const {
  // @@protoc_insertion_point(field_get:netspeak.service.PhraseConstraints.words_max)
  return _internal_words_max();
}
inline void PhraseConstraints::_internal_set_words_max(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  words_max_ = value;
}
inline void PhraseConstraints::set_words_max(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_words_max(value);
  // @@protoc_insertion_point(field_set:netspeak.service.PhraseConstraints.words_max)
}

// -------------------------------------------------------------------

// Phrase_Word

// .netspeak.service.Phrase.Word.Tag tag = 1;
inline void Phrase_Word::clear_tag() {
  tag_ = 0;
}
inline ::netspeak::service::Phrase_Word_Tag Phrase_Word::_internal_tag() const {
  return static_cast< ::netspeak::service::Phrase_Word_Tag >(tag_);
}
inline ::netspeak::service::Phrase_Word_Tag Phrase_Word::tag() const {
  // @@protoc_insertion_point(field_get:netspeak.service.Phrase.Word.tag)
  return _internal_tag();
}
inline void Phrase_Word::_internal_set_tag(::netspeak::service::Phrase_Word_Tag value) {
  
  tag_ = value;
}
inline void Phrase_Word::set_tag(::netspeak::service::Phrase_Word_Tag value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:netspeak.service.Phrase.Word.tag)
}

// string text = 2;
inline void Phrase_Word::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Phrase_Word::text() const {
  // @@protoc_insertion_point(field_get:netspeak.service.Phrase.Word.text)
  return _internal_text();
}
inline void Phrase_Word::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:netspeak.service.Phrase.Word.text)
}
inline std::string* Phrase_Word::mutable_text() {
  // @@protoc_insertion_point(field_mutable:netspeak.service.Phrase.Word.text)
  return _internal_mutable_text();
}
inline const std::string& Phrase_Word::_internal_text() const {
  return text_.GetNoArena();
}
inline void Phrase_Word::_internal_set_text(const std::string& value) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Phrase_Word::set_text(std::string&& value) {
  
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netspeak.service.Phrase.Word.text)
}
inline void Phrase_Word::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netspeak.service.Phrase.Word.text)
}
inline void Phrase_Word::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netspeak.service.Phrase.Word.text)
}
inline std::string* Phrase_Word::_internal_mutable_text() {
  
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Phrase_Word::release_text() {
  // @@protoc_insertion_point(field_release:netspeak.service.Phrase.Word.text)
  
  return text_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Phrase_Word::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:netspeak.service.Phrase.Word.text)
}

// -------------------------------------------------------------------

// Phrase

// uint64 id = 1;
inline void Phrase::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Phrase::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Phrase::id() const {
  // @@protoc_insertion_point(field_get:netspeak.service.Phrase.id)
  return _internal_id();
}
inline void Phrase::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Phrase::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:netspeak.service.Phrase.id)
}

// uint64 frequency = 2;
inline void Phrase::clear_frequency() {
  frequency_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Phrase::_internal_frequency() const {
  return frequency_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Phrase::frequency() const {
  // @@protoc_insertion_point(field_get:netspeak.service.Phrase.frequency)
  return _internal_frequency();
}
inline void Phrase::_internal_set_frequency(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  frequency_ = value;
}
inline void Phrase::set_frequency(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:netspeak.service.Phrase.frequency)
}

// repeated .netspeak.service.Phrase.Word words = 3;
inline int Phrase::_internal_words_size() const {
  return words_.size();
}
inline int Phrase::words_size() const {
  return _internal_words_size();
}
inline void Phrase::clear_words() {
  words_.Clear();
}
inline ::netspeak::service::Phrase_Word* Phrase::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:netspeak.service.Phrase.words)
  return words_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Phrase_Word >*
Phrase::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:netspeak.service.Phrase.words)
  return &words_;
}
inline const ::netspeak::service::Phrase_Word& Phrase::_internal_words(int index) const {
  return words_.Get(index);
}
inline const ::netspeak::service::Phrase_Word& Phrase::words(int index) const {
  // @@protoc_insertion_point(field_get:netspeak.service.Phrase.words)
  return _internal_words(index);
}
inline ::netspeak::service::Phrase_Word* Phrase::_internal_add_words() {
  return words_.Add();
}
inline ::netspeak::service::Phrase_Word* Phrase::add_words() {
  // @@protoc_insertion_point(field_add:netspeak.service.Phrase.words)
  return _internal_add_words();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Phrase_Word >&
Phrase::words() const {
  // @@protoc_insertion_point(field_list:netspeak.service.Phrase.words)
  return words_;
}

// -------------------------------------------------------------------

// SearchResponse_Result

// repeated .netspeak.service.Phrase phrases = 1;
inline int SearchResponse_Result::_internal_phrases_size() const {
  return phrases_.size();
}
inline int SearchResponse_Result::phrases_size() const {
  return _internal_phrases_size();
}
inline void SearchResponse_Result::clear_phrases() {
  phrases_.Clear();
}
inline ::netspeak::service::Phrase* SearchResponse_Result::mutable_phrases(int index) {
  // @@protoc_insertion_point(field_mutable:netspeak.service.SearchResponse.Result.phrases)
  return phrases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Phrase >*
SearchResponse_Result::mutable_phrases() {
  // @@protoc_insertion_point(field_mutable_list:netspeak.service.SearchResponse.Result.phrases)
  return &phrases_;
}
inline const ::netspeak::service::Phrase& SearchResponse_Result::_internal_phrases(int index) const {
  return phrases_.Get(index);
}
inline const ::netspeak::service::Phrase& SearchResponse_Result::phrases(int index) const {
  // @@protoc_insertion_point(field_get:netspeak.service.SearchResponse.Result.phrases)
  return _internal_phrases(index);
}
inline ::netspeak::service::Phrase* SearchResponse_Result::_internal_add_phrases() {
  return phrases_.Add();
}
inline ::netspeak::service::Phrase* SearchResponse_Result::add_phrases() {
  // @@protoc_insertion_point(field_add:netspeak.service.SearchResponse.Result.phrases)
  return _internal_add_phrases();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Phrase >&
SearchResponse_Result::phrases() const {
  // @@protoc_insertion_point(field_list:netspeak.service.SearchResponse.Result.phrases)
  return phrases_;
}

// repeated string unknown_words = 2;
inline int SearchResponse_Result::_internal_unknown_words_size() const {
  return unknown_words_.size();
}
inline int SearchResponse_Result::unknown_words_size() const {
  return _internal_unknown_words_size();
}
inline void SearchResponse_Result::clear_unknown_words() {
  unknown_words_.Clear();
}
inline std::string* SearchResponse_Result::add_unknown_words() {
  // @@protoc_insertion_point(field_add_mutable:netspeak.service.SearchResponse.Result.unknown_words)
  return _internal_add_unknown_words();
}
inline const std::string& SearchResponse_Result::_internal_unknown_words(int index) const {
  return unknown_words_.Get(index);
}
inline const std::string& SearchResponse_Result::unknown_words(int index) const {
  // @@protoc_insertion_point(field_get:netspeak.service.SearchResponse.Result.unknown_words)
  return _internal_unknown_words(index);
}
inline std::string* SearchResponse_Result::mutable_unknown_words(int index) {
  // @@protoc_insertion_point(field_mutable:netspeak.service.SearchResponse.Result.unknown_words)
  return unknown_words_.Mutable(index);
}
inline void SearchResponse_Result::set_unknown_words(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:netspeak.service.SearchResponse.Result.unknown_words)
  unknown_words_.Mutable(index)->assign(value);
}
inline void SearchResponse_Result::set_unknown_words(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:netspeak.service.SearchResponse.Result.unknown_words)
  unknown_words_.Mutable(index)->assign(std::move(value));
}
inline void SearchResponse_Result::set_unknown_words(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unknown_words_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:netspeak.service.SearchResponse.Result.unknown_words)
}
inline void SearchResponse_Result::set_unknown_words(int index, const char* value, size_t size) {
  unknown_words_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:netspeak.service.SearchResponse.Result.unknown_words)
}
inline std::string* SearchResponse_Result::_internal_add_unknown_words() {
  return unknown_words_.Add();
}
inline void SearchResponse_Result::add_unknown_words(const std::string& value) {
  unknown_words_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:netspeak.service.SearchResponse.Result.unknown_words)
}
inline void SearchResponse_Result::add_unknown_words(std::string&& value) {
  unknown_words_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:netspeak.service.SearchResponse.Result.unknown_words)
}
inline void SearchResponse_Result::add_unknown_words(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unknown_words_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:netspeak.service.SearchResponse.Result.unknown_words)
}
inline void SearchResponse_Result::add_unknown_words(const char* value, size_t size) {
  unknown_words_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:netspeak.service.SearchResponse.Result.unknown_words)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchResponse_Result::unknown_words() const {
  // @@protoc_insertion_point(field_list:netspeak.service.SearchResponse.Result.unknown_words)
  return unknown_words_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchResponse_Result::mutable_unknown_words() {
  // @@protoc_insertion_point(field_mutable_list:netspeak.service.SearchResponse.Result.unknown_words)
  return &unknown_words_;
}

// -------------------------------------------------------------------

// SearchResponse_Error

// .netspeak.service.SearchResponse.Error.Kind kind = 1;
inline void SearchResponse_Error::clear_kind() {
  kind_ = 0;
}
inline ::netspeak::service::SearchResponse_Error_Kind SearchResponse_Error::_internal_kind() const {
  return static_cast< ::netspeak::service::SearchResponse_Error_Kind >(kind_);
}
inline ::netspeak::service::SearchResponse_Error_Kind SearchResponse_Error::kind() const {
  // @@protoc_insertion_point(field_get:netspeak.service.SearchResponse.Error.kind)
  return _internal_kind();
}
inline void SearchResponse_Error::_internal_set_kind(::netspeak::service::SearchResponse_Error_Kind value) {
  
  kind_ = value;
}
inline void SearchResponse_Error::set_kind(::netspeak::service::SearchResponse_Error_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:netspeak.service.SearchResponse.Error.kind)
}

// string message = 2;
inline void SearchResponse_Error::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SearchResponse_Error::message() const {
  // @@protoc_insertion_point(field_get:netspeak.service.SearchResponse.Error.message)
  return _internal_message();
}
inline void SearchResponse_Error::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:netspeak.service.SearchResponse.Error.message)
}
inline std::string* SearchResponse_Error::mutable_message() {
  // @@protoc_insertion_point(field_mutable:netspeak.service.SearchResponse.Error.message)
  return _internal_mutable_message();
}
inline const std::string& SearchResponse_Error::_internal_message() const {
  return message_.GetNoArena();
}
inline void SearchResponse_Error::_internal_set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SearchResponse_Error::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netspeak.service.SearchResponse.Error.message)
}
inline void SearchResponse_Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netspeak.service.SearchResponse.Error.message)
}
inline void SearchResponse_Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netspeak.service.SearchResponse.Error.message)
}
inline std::string* SearchResponse_Error::_internal_mutable_message() {
  
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SearchResponse_Error::release_message() {
  // @@protoc_insertion_point(field_release:netspeak.service.SearchResponse.Error.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SearchResponse_Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:netspeak.service.SearchResponse.Error.message)
}

// -------------------------------------------------------------------

// SearchResponse

// .netspeak.service.SearchResponse.Result result = 1;
inline bool SearchResponse::_internal_has_result() const {
  return response_case() == kResult;
}
inline bool SearchResponse::has_result() const {
  return _internal_has_result();
}
inline void SearchResponse::set_has_result() {
  _oneof_case_[0] = kResult;
}
inline void SearchResponse::clear_result() {
  if (_internal_has_result()) {
    delete response_.result_;
    clear_has_response();
  }
}
inline ::netspeak::service::SearchResponse_Result* SearchResponse::release_result() {
  // @@protoc_insertion_point(field_release:netspeak.service.SearchResponse.result)
  if (_internal_has_result()) {
    clear_has_response();
      ::netspeak::service::SearchResponse_Result* temp = response_.result_;
    response_.result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::netspeak::service::SearchResponse_Result& SearchResponse::_internal_result() const {
  return _internal_has_result()
      ? *response_.result_
      : *reinterpret_cast< ::netspeak::service::SearchResponse_Result*>(&::netspeak::service::_SearchResponse_Result_default_instance_);
}
inline const ::netspeak::service::SearchResponse_Result& SearchResponse::result() const {
  // @@protoc_insertion_point(field_get:netspeak.service.SearchResponse.result)
  return _internal_result();
}
inline ::netspeak::service::SearchResponse_Result* SearchResponse::_internal_mutable_result() {
  if (!_internal_has_result()) {
    clear_response();
    set_has_result();
    response_.result_ = CreateMaybeMessage< ::netspeak::service::SearchResponse_Result >(
        GetArenaNoVirtual());
  }
  return response_.result_;
}
inline ::netspeak::service::SearchResponse_Result* SearchResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable:netspeak.service.SearchResponse.result)
  return _internal_mutable_result();
}

// .netspeak.service.SearchResponse.Error error = 2;
inline bool SearchResponse::_internal_has_error() const {
  return response_case() == kError;
}
inline bool SearchResponse::has_error() const {
  return _internal_has_error();
}
inline void SearchResponse::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void SearchResponse::clear_error() {
  if (_internal_has_error()) {
    delete response_.error_;
    clear_has_response();
  }
}
inline ::netspeak::service::SearchResponse_Error* SearchResponse::release_error() {
  // @@protoc_insertion_point(field_release:netspeak.service.SearchResponse.error)
  if (_internal_has_error()) {
    clear_has_response();
      ::netspeak::service::SearchResponse_Error* temp = response_.error_;
    response_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::netspeak::service::SearchResponse_Error& SearchResponse::_internal_error() const {
  return _internal_has_error()
      ? *response_.error_
      : *reinterpret_cast< ::netspeak::service::SearchResponse_Error*>(&::netspeak::service::_SearchResponse_Error_default_instance_);
}
inline const ::netspeak::service::SearchResponse_Error& SearchResponse::error() const {
  // @@protoc_insertion_point(field_get:netspeak.service.SearchResponse.error)
  return _internal_error();
}
inline ::netspeak::service::SearchResponse_Error* SearchResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_response();
    set_has_error();
    response_.error_ = CreateMaybeMessage< ::netspeak::service::SearchResponse_Error >(
        GetArenaNoVirtual());
  }
  return response_.error_;
}
inline ::netspeak::service::SearchResponse_Error* SearchResponse::mutable_error() {
  // @@protoc_insertion_point(field_mutable:netspeak.service.SearchResponse.error)
  return _internal_mutable_error();
}

inline bool SearchResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void SearchResponse::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline SearchResponse::ResponseCase SearchResponse::response_case() const {
  return SearchResponse::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CorporaRequest

// -------------------------------------------------------------------

// Corpus

// string key = 1;
inline void Corpus::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Corpus::key() const {
  // @@protoc_insertion_point(field_get:netspeak.service.Corpus.key)
  return _internal_key();
}
inline void Corpus::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:netspeak.service.Corpus.key)
}
inline std::string* Corpus::mutable_key() {
  // @@protoc_insertion_point(field_mutable:netspeak.service.Corpus.key)
  return _internal_mutable_key();
}
inline const std::string& Corpus::_internal_key() const {
  return key_.GetNoArena();
}
inline void Corpus::_internal_set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Corpus::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netspeak.service.Corpus.key)
}
inline void Corpus::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netspeak.service.Corpus.key)
}
inline void Corpus::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netspeak.service.Corpus.key)
}
inline std::string* Corpus::_internal_mutable_key() {
  
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Corpus::release_key() {
  // @@protoc_insertion_point(field_release:netspeak.service.Corpus.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Corpus::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:netspeak.service.Corpus.key)
}

// string name = 2;
inline void Corpus::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Corpus::name() const {
  // @@protoc_insertion_point(field_get:netspeak.service.Corpus.name)
  return _internal_name();
}
inline void Corpus::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:netspeak.service.Corpus.name)
}
inline std::string* Corpus::mutable_name() {
  // @@protoc_insertion_point(field_mutable:netspeak.service.Corpus.name)
  return _internal_mutable_name();
}
inline const std::string& Corpus::_internal_name() const {
  return name_.GetNoArena();
}
inline void Corpus::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Corpus::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netspeak.service.Corpus.name)
}
inline void Corpus::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netspeak.service.Corpus.name)
}
inline void Corpus::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netspeak.service.Corpus.name)
}
inline std::string* Corpus::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Corpus::release_name() {
  // @@protoc_insertion_point(field_release:netspeak.service.Corpus.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Corpus::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:netspeak.service.Corpus.name)
}

// string language = 3;
inline void Corpus::clear_language() {
  language_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Corpus::language() const {
  // @@protoc_insertion_point(field_get:netspeak.service.Corpus.language)
  return _internal_language();
}
inline void Corpus::set_language(const std::string& value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:netspeak.service.Corpus.language)
}
inline std::string* Corpus::mutable_language() {
  // @@protoc_insertion_point(field_mutable:netspeak.service.Corpus.language)
  return _internal_mutable_language();
}
inline const std::string& Corpus::_internal_language() const {
  return language_.GetNoArena();
}
inline void Corpus::_internal_set_language(const std::string& value) {
  
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Corpus::set_language(std::string&& value) {
  
  language_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netspeak.service.Corpus.language)
}
inline void Corpus::set_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netspeak.service.Corpus.language)
}
inline void Corpus::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netspeak.service.Corpus.language)
}
inline std::string* Corpus::_internal_mutable_language() {
  
  return language_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Corpus::release_language() {
  // @@protoc_insertion_point(field_release:netspeak.service.Corpus.language)
  
  return language_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Corpus::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:netspeak.service.Corpus.language)
}

// -------------------------------------------------------------------

// CorporaResponse

// repeated .netspeak.service.Corpus corpora = 1;
inline int CorporaResponse::_internal_corpora_size() const {
  return corpora_.size();
}
inline int CorporaResponse::corpora_size() const {
  return _internal_corpora_size();
}
inline void CorporaResponse::clear_corpora() {
  corpora_.Clear();
}
inline ::netspeak::service::Corpus* CorporaResponse::mutable_corpora(int index) {
  // @@protoc_insertion_point(field_mutable:netspeak.service.CorporaResponse.corpora)
  return corpora_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Corpus >*
CorporaResponse::mutable_corpora() {
  // @@protoc_insertion_point(field_mutable_list:netspeak.service.CorporaResponse.corpora)
  return &corpora_;
}
inline const ::netspeak::service::Corpus& CorporaResponse::_internal_corpora(int index) const {
  return corpora_.Get(index);
}
inline const ::netspeak::service::Corpus& CorporaResponse::corpora(int index) const {
  // @@protoc_insertion_point(field_get:netspeak.service.CorporaResponse.corpora)
  return _internal_corpora(index);
}
inline ::netspeak::service::Corpus* CorporaResponse::_internal_add_corpora() {
  return corpora_.Add();
}
inline ::netspeak::service::Corpus* CorporaResponse::add_corpora() {
  // @@protoc_insertion_point(field_add:netspeak.service.CorporaResponse.corpora)
  return _internal_add_corpora();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::netspeak::service::Corpus >&
CorporaResponse::corpora() const {
  // @@protoc_insertion_point(field_list:netspeak.service.CorporaResponse.corpora)
  return corpora_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace service
}  // namespace netspeak

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::netspeak::service::Phrase_Word_Tag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netspeak::service::Phrase_Word_Tag>() {
  return ::netspeak::service::Phrase_Word_Tag_descriptor();
}
template <> struct is_proto_enum< ::netspeak::service::SearchResponse_Error_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netspeak::service::SearchResponse_Error_Kind>() {
  return ::netspeak::service::SearchResponse_Error_Kind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_NetspeakService_2eproto
